print('1.Наследование')

# Концепция наследования подразумевает то что у любого класса будет класс наследник который
# будет наследовать параметры от родительского класса


# Создадим основной класс:

class Building:
    year = None
    city = None

    def __init__(self, year, city): # Ключевое слово __init__ обозначет что это функция конструктор

        self.year = year
        self.city = city

    def get_info(self):
        print('Year of building is', self.year, 'City of building is', self.city, 'Pupils in school is', self.pu )



# Но что делать если объекта school у нас будет 10 дополнительных функций? Нам нужно тогда прописывать 10 этих функций в
# родительском классе...

# Или же мы можем создать класс наследник, не нагромождая родительский класс:

class School(Building): # передаваемый аргумент Building является тем что мы передаем всю начинку класса Building в класс School
    # То есть класс School это класс наследник класса Building
    pupils = 0 # Здесь нам необходимо создавать класс наследник по той причине что ученики могут быть только в уч заведениях

    def __init__(self, pupils, year, city): # и дополнительно мы получаем аргументы из родительского класса
        self.pupils = pupils

        # Функция super
        super(School, self).__init__(year, city, pupils)

#         Эта функция вызывает класс родитель со всеми его функциями
#         Далее мы говорим от какого класса наследника мы передаем параметры в класс родитель
#         Далее мы вызываем метод (конструктор, который унаследован), и передаем значение из класса наследника

S = School(100, 2001, 'Kyiv')
S.get_info()




